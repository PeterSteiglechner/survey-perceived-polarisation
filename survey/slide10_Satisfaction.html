{% block styles %}
<link rel="stylesheet" href="{{ static 'main.css' }}" />
{% endblock %} {{ block content }}
<script src="{% static 'colors.js' %}"></script>

<h2>{{ page_title }}</h2>

<div>
  <p>{{instru1}}</p>
  <canvas
    id="dragCanvas"
    width="500"
    height="500"
    style="
      border: 0px solid #333;
      background: #fafafa;
      display: block;
      margin: 20px 0;
      cursor: grab;
    "
  ></canvas>

  <div
    id="popup"
    style="
      display: none;
      position: absolute;
      width: 320px;
      padding: 8px;
      background: white;
      border: 2px solid #333;
      border-radius: 6px;
      box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      font-size: 13px;
      line-height: 1.3;
    "
  ></div>

  <input type="hidden" name="positions" id="positions" />

  <br />

  <div class="card-section">
    <div class="card">
      <!-- Satisfaction Slider -->
      <label class="form-label">{{ question }}</label>
      <input
        type="range"
        class="likert-slider"
        name="satisfaction"
        id="satisfactionSlider"
        min="{{ satisfaction_min }}"
        max="{{ satisfaction_max }}"
        step="1"
        style="color: #aaaaaa; background: #ccc"
        oninput="handleSliderInput('satisfaction', this.value)"
        required
      />
      <div
        style="display: flex; justify-content: space-between; margin-top: 5px"
      >
        <span style="font-size: 10pt; color: #777; margin-top: -3pt"
          >{{ satisfaction_min_label }}</span
        >
        <span style="font-size: 10pt; color: #777; margin-top: -3pt"
          >{{ satisfaction_max_label }}</span
        >
      </div>
      <div
        style="
          text-align: center;
          margin-top: 5px;
          margin-bottom: 35px;
          font-size: 13pt;
        "
      >
        {% if lan_en %} Selected value: {% else %} Ausgew채hlter Wert: {%endif%}
        <span id="satisfactionsliderValue" style="color: #999; font-size: 13pt"
          ><strong>
            {% if lan_en %}Please move the slider{% else %}Bitte bewegen Sie den
            Schieberegler{% endif %}</strong
          >
        </span>
      </div>
      {{ formfield_errors "satisfaction" }}

      <!-- Accurate Mapping Slider -->
      <label class="form-label">{{ questionaccurateMapping }}</label>
      <input
        type="range"
        class="likert-slider"
        name="accurateMapping"
        id="accSlider"
        min="{{ acc_min }}"
        max="{{ acc_max }}"
        step="1"
        style="color: #aaaaaa; background: #ccc"
        oninput="handleSliderInput('accurateMapping', this.value)"
        required
      />
      <div
        style="display: flex; justify-content: space-between; margin-top: 5px"
      >
        <span style="font-size: 10pt; color: #777; margin-top: -3pt"
          >{{ acc_min_label }}</span
        >
        <span style="font-size: 10pt; color: #777; margin-top: -3pt"
          >{{ acc_max_label }}</span
        >
      </div>
      <div
        style="
          text-align: center;
          margin-top: 5px;
          margin-bottom: 35px;
          font-size: 13pt;
        "
      >
        {% if lan_en %} Selected value: {% else %} Ausgew채hlter Wert: {%endif%}
        <span id="accsliderValue" style="color: #999; font-size: 13pt">
          <strong>
            {% if lan_en %}Please move the slider{% else %}Bitte bewegen Sie den
            Schieberegler{% endif %}
          </strong>
        </span>
        {{ formfield_errors "accurateMapping" }}
      </div>
    </div>

    <br />

    <div class="card">{{explain_text}} {{ formfield "satisfaction_text" }}</div>
  </div>

  <br />

  <div
    style="display: flex; justify-content: space-between; align-items: center"
  >
    {% if lan_en %} {{ next_button }}
    <div style="margin-left: auto">Page {{nslide}}/{{maxslides}}</div>
    {% else %}
    <button
      type="submit"
      class="otree-btn-next btn btn-primary"
      id="nextButton"
      disabled
      style="opacity: 0.5"
    >
      Weiter
    </button>
    <div style="margin-left: auto">Seite {{nslide}}/{{maxslides}}</div>
    {% endif %}
  </div>
</div>

<script>
  let slidersTouched = {
    satisfaction: false,
    accurateMapping: false
  };

  function handleSliderInput(sliderName, value) {
    slidersTouched[sliderName] = true;

    // Update displayed value
    const valueSpan = sliderName === 'satisfaction' ? 'satisfactionsliderValue' : 'accsliderValue';
    const sliderSpan = document.getElementById(valueSpan);
    sliderSpan.textContent = value;
    sliderSpan.style.color = 'black';

    // Update slider background gradient
    const slider = sliderName === 'satisfaction' ? document.getElementById('satisfactionSlider') : document.getElementById('accSlider');
    const percentage = ((value - slider.min) / (slider.max - slider.min)) * 100;
    slider.style.background = `linear-gradient(to right, #007bff 0%, #007bff ${percentage}%, #e0e0e0 ${percentage}%, #e0e0e0 100%)`;

    // Enable next button if at least one slider touched
    const nextButton = document.getElementById('nextButton');
    if (nextButton && (slidersTouched.satisfaction || slidersTouched.accurateMapping)) {
      nextButton.disabled = false;
      nextButton.style.opacity = '1';
    }
  }

  // Form validation before submission
  document.addEventListener('DOMContentLoaded', function() {
    const form = document.querySelector('form');
    if (form) {
      form.addEventListener('submit', function(e) {
        if (!slidersTouched.satisfaction && !slidersTouched.accurateMapping) {
          e.preventDefault();
          const lang = {% if lan_en %}true{% else %}false{% endif %};
          alert(lang ? 'Please move the slider to select a value.' : 'Bitte bewegen Sie den Schieberegler, um einen Wert auszuw채hlen.');
          return false;
        }
      });
    }
  });
</script>

<script>

      function getLikertLabel(val) {
          const numVal = parseInt(val);
          {% if lan_en %}
          if (numVal <= -71) return "Strongly Disagree";
          else if (numVal <= -41) return "Disagree";
          else if (numVal <= -11) return "Somewhat Disagree";
          else if (numVal <= 11) return "Neutral";
          else if (numVal <= 41) return "Somewhat Agree";
          else if (numVal <= 71) return "Agree";
          else return "Strongly Agree";
          {% else %}
          if (numVal <= -71) return "Stimme 체berhaupt nicht zu";
          else if (numVal <= -41) return "Stimme nicht zu";
          else if (numVal <= -11) return "Stimme eher nicht zu";
          else if (numVal <= 11) return "Neutral";
          else if (numVal <= 41) return "Stimme eher zu";
          else if (numVal <= 71) return "Stimme zu";
          else return "Stimme voll und ganz zu";
          {% endif %}
      }


      document.addEventListener("DOMContentLoaded", function () {
          const canvas = document.getElementById("dragCanvas");
          const ctx = canvas.getContext("2d");
          const points = [
              {% for dot in dots %}
                  {
                  name_disp: "{{ dot.name_disp }}",
                  varname: "{{ dot.varname }}",
                  x: {{ dot.x }},
                  y: {{ dot.y }},
                  dottype: "{{ dot.dottype }}" ,
                  descr:"{{ dot.descr }}",
                  radius: 12
                  },
              {% endfor %}
          ];
          const popup = document.getElementById("popup");

          let hoveredPoint = null;

          console.log("Loaded points:", points);

          function drawCanvas() {
              ctx.clearRect(0, 0, canvas.width, canvas.height);

              // Draw the boundary square with enhanced styling
              ctx.strokeStyle = "#333";
              ctx.lineWidth = 1;
              ctx.strokeRect(0, 0, canvas.height, canvas.height);

              // Draw all points
              points.forEach(p => {
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);

                  // Set fill color based on type
                  ctx.fillStyle =  COLORS[p.varname] || COLORS[p.dottype] || "white";
                  ctx.fill();

                  // Add border with hover effect
                  ctx.strokeStyle = p === hoveredPoint ? "#fff" : "#333";
                  ctx.lineWidth = p === hoveredPoint ? 3 : 2;
                  ctx.stroke();

                  // Draw label with better positioning
                  ctx.fillStyle = "#333";
                  ctx.font = "12px Arial";
                  ctx.textAlign = "center";
                  ctx.textBaseline = "bottom";
                  ctx.fillText(p.name_disp, p.x, p.y - 18);
              });
          }

          function getMousePos(evt) {
              const rect = canvas.getBoundingClientRect();
              return {
                  x: evt.clientX - rect.left,
                  y: evt.clientY - rect.top
              };
          }

          function getTouchPos(touch) {
              const rect = canvas.getBoundingClientRect();
              return {
                  x: touch.clientX - rect.left,
                  y: touch.clientY - rect.top
              };
          }

          function findPoint(pos) {
              return points.find(p => Math.hypot(p.x - pos.x, p.y - pos.y) < p.radius);
          }

          function showPopup(point, mouseX, mouseY) {
              const canvasRect = canvas.getBoundingClientRect();
              const canvasOffsetTop = canvas.offsetTop;
              const canvasOffsetLeft = canvas.offsetLeft;

              // Position popup to the right of canvas, starting at x=510px from canvas left
              popup.style.left = `${canvasOffsetLeft + 505}px`;
              popup.style.top = `${canvasOffsetTop}px`;

              // Function to get color styling based on answer value
  function getAnswerStyling(answer) {
      const label = getLikertLabel(answer);

      const trimmedAnswer = label.toLowerCase().trim();
      let backgroundColor = '';
      let texcolor = "black";

      if (trimmedAnswer === 'strongly disagree' || trimmedAnswer === 'stimme 체berhaupt nicht zu') {
          backgroundColor = 'rgba(220, 53, 69, 1)'; // deep red
          texcolor = "rgb(255, 255, 255)";
      } else if (trimmedAnswer === 'disagree' || trimmedAnswer === 'stimme nicht zu') {
          backgroundColor = 'rgba(255, 99, 132, 0.9)'; // medium red
          texcolor = "rgb(255, 255, 255)";
      } else if (trimmedAnswer === 'somewhat disagree' || trimmedAnswer === 'stimme eher nicht zu') {
          backgroundColor = 'rgba(255, 178, 102, 0.8)'; // orange-red
      } else if (trimmedAnswer === 'neutral' || trimmedAnswer === 'teils/teils') {
          backgroundColor = 'rgba(201, 203, 207, 0.6)'; // light gray
      } else if (trimmedAnswer === 'somewhat agree' || trimmedAnswer === 'stimme eher zu') {
          backgroundColor = 'rgba(144, 238, 144, 0.8)'; // light green
      } else if (trimmedAnswer === 'agree' || trimmedAnswer === 'stimme zu') {
          backgroundColor = 'rgba(60, 179, 113, 0.9)'; // medium green
          texcolor = "rgb(255, 255, 255)";
      } else if (trimmedAnswer === 'strongly agree' || trimmedAnswer === 'stimme voll und ganz zu') {
          backgroundColor = 'rgba(40, 167, 69, 1)'; // deep green
          texcolor = "rgb(255, 255, 255)";
      }

      return backgroundColor
          ? `background-color: ${backgroundColor}; color: ${texcolor}; padding: 4px 0px; border-radius: 0px;`
          : '';
  }


              // Create table from description
              let tableContent = '';
              if (point.descr && point.descr.includes(';')) {
                  const lines = point.descr.split(';').map(line => line.trim()).filter(line => line);
                  tableContent = lines.map(line => {
                      const colonIndex = line.indexOf(':');
                      if (colonIndex !== -1) {
                          const question = line.substring(0, colonIndex);
                          const answer = line.substring(colonIndex + 1).trim();
                          const label = getLikertLabel(answer);
                          const answerStyling = getAnswerStyling(answer);

                          return `<tr><td style="padding: 6px 4px 4px 0; vertical-align: center; border-bottom: 2px solid #eee; width: 55%; word-wrap: break-word; line-height: 1.3;">${question}</td></td><td style="padding: 6px 4px 4px 0; vertical-align: center; border-bottom: 2px solid #eee; font-weight: bold; width: 39%; word-wrap: break-word;line-height:1.8"><span style="${answerStyling}">${label}</span></td></tr>`;
                      }
                      return `<tr><td colspan="2" style="padding: 10px 0px; border-bottom: 1px solid #eee;">${line}</td></tr>`;
                  }).join('');
              } else {
                  tableContent = `<tr><td style="padding: 0px 0;">${point.descr || 'No description available'}</td></tr>`;
              }
              popup.innerHTML = `
                  <strong style="font-size: 12px;">${point.name_disp}</strong><br><br>
                  <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                      ${tableContent}
                  </table>
              `;
              popup.style.display = "block";
          }

          // Touch event handlers
          canvas.addEventListener("touchstart", function (evt) {
              const touch = evt.touches[0];
              const touchPos = getTouchPos(touch);
              const touchedPoint = findPoint(touchPos);

              if (touchedPoint) {
                  showPopup(touchedPoint, touchPos.x, touchPos.y);
              } else {
                  popup.style.display = "none";
              }
              evt.preventDefault();
          }, { passive: false });

          canvas.addEventListener("touchend", function () {
              hoveredPoint = null;
              drawCanvas();
          }, { passive: false });

          // Mouse event handlers (for desktop)
          canvas.addEventListener("mousedown", function (evt) {
              const mousePos = getMousePos(evt);
              const clickedPoint = findPoint(mousePos);

              if (clickedPoint) {
                  showPopup(clickedPoint, mousePos.x, mousePos.y);
              } else {
                  popup.style.display = "none";
              }
          });

          canvas.addEventListener("mousemove", function (evt) {
              const mousePos = getMousePos(evt);
              const newHoveredPoint = findPoint(mousePos);

              // Update cursor based on what we're hovering over
              if (newHoveredPoint) {
                  canvas.style.cursor = "pointer";
              } else {
                  canvas.style.cursor = "default";
              }

              if (newHoveredPoint !== hoveredPoint) {
                  hoveredPoint = newHoveredPoint;
                  drawCanvas();
              }
          });

          canvas.addEventListener("mouseleave", function () {
              hoveredPoint = null;
              canvas.style.cursor = "default";
              drawCanvas();
          });

          document.addEventListener("click", function (e) {
              if (!canvas.contains(e.target) && !popup.contains(e.target)) {
                  popup.style.display = "none";
              }
          });

          // Initial draw
          drawCanvas();
      });
</script>
<script>
  document.querySelectorAll(".option-cards").forEach((group) => {
    const name = group.dataset.field;
    group.querySelectorAll('input[type="radio"]').forEach((radio) => {
      radio.addEventListener("change", () => {
        group.querySelectorAll(".option-card").forEach((card) => {
          card.classList.remove("selected");
        });
        radio.closest(".option-card").classList.add("selected");
      });
    });
  });
</script>
{{endblock}}
