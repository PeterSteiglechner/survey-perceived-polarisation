{% load static %} {% block styles %}
<link rel="stylesheet" href="{{ static 'main.css' }}" />
{% endblock %} {% block content %}
<script src="{% static 'colors.js' %}"></script>
<script src="{{ static 'global.js' }}"></script>

<div class="container">
  <h2>{{page_title}}</h2>

  <p>{{instru1}}</p>

  <p>{{instruRoom}}</p>

  <div class="yellow-instructions">{{instru_main}}</div>

  <div class="yellow-instructions">{{no_wrong_answers}}</div>

  <canvas
    id="dragCanvas"
    width="{{ canvas_width_parkingLot }}"
    height="{{ canvas_height }}"
    style="
      border: 0px solid #333;
      background: #fafafa;
      display: block;
      margin: 0px 0;
      cursor: grab;
      touch-action: none;
    "
  ></canvas>

  <input type="hidden" name="positions" id="positions" />
</div>

<div class="red-instructions">
  <p>{{all_dots_instr}}</p>
</div>

<div class="nav-container">
  {% if lan_en %}
  <button type="submit" class="otree-btn-next btn btn-primary big-button">
    Continue
  </button>
  <div class="nav-progress">Page {{nslide}}/{{maxslides}}</div>
  {% else %}
  <button type="submit" class="otree-btn-next btn btn-primary big-button">
    Weiter
  </button>
  <div class="nav-progress">Seite {{nslide}}/{{maxslides}}</div>
  {% endif %}
</div>

<script>
  // Run only after everything (DOM + CSS + fonts) is ready
  window.addEventListener("load", function () {
    const canvas = document.getElementById("dragCanvas");
    const ctx = canvas.getContext("2d");

    const points = [
      {% for dot in dots %}
      {
        name_disp: "{{ dot.name_disp }}",
        varname: "{{ dot.varname }}",
        x: {{ dot.x }},
        y: {{ dot.y }},
        dottype: "{{ dot.dottype }}",
        descr: "{{ dot.descr }}",
        radius: 12,
        color: COLORS["{{dot.varname}}"] || COLORS["{{dot.dottype}}"] || "white",
        t_last_moved: {{ dot.t_last_moved }},
        t_first_moved: {{ dot.t_first_moved }}
      },
      {% endfor %}
    ];

    let draggingPoint = null,
        hoveredPoint = null,
        lastMousePos = { x: 0, y: 0 },
        lastTouchPos = { x: 0, y: 0 };

         function drawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the boundary square with enhanced styling
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, canvas.height, canvas.height);


                // Draw all points
                points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);

                    // Set fill color based on type
                    ctx.fillStyle =p.color;
                    ctx.fill();

                    // Add border with hover effect
                    ctx.strokeStyle = p === hoveredPoint ? "#fff" : "#333";
                    ctx.lineWidth = p === hoveredPoint ? 3 : 2;
                    ctx.stroke();

                    // Draw name with better positioning
                    ctx.fillStyle = "#333";
                    ctx.font = "12px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "bottom";
                    ctx.fillText(p.name_disp, p.x, p.y - 15);
                });
            }


      function recordMove(dot) {
            const now = Math.floor(Date.now() / 1000);
            if (dot.t_first_moved === -1) dot.t_first_moved = now;
            dot.t_last_moved = now;
          }



      function getMousePos(evt) {
          const rect = canvas.getBoundingClientRect();
          return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
          };
      }

      function getTouchPos(touch) {
          const rect = canvas.getBoundingClientRect();
          return {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top
          };
      }

      function findPoint(pos) {
          return points.find(p => Math.hypot(p.x - pos.x, p.y - pos.y) < p.radius);
      }


      // Validation function for boundary checking
      function allPointsInsideBox() {
          return points.every(p => p.x >= 0 && p.x <= canvas.height && p.y >= 0 && p.y <= canvas.height);
      }

    // Prevent native drag
    ["dragstart", "drag", "dragend"].forEach(ev =>
      canvas.addEventListener(ev, e => e.preventDefault())
    );

    // Touch handlers
    canvas.addEventListener("touchstart", evt => {
      const touchPos = getTouchPos(evt.touches[0]);
      lastTouchPos = touchPos;
      draggingPoint = findPoint(touchPos) || null;
      drawCanvas();
      evt.preventDefault();
    }, { passive: false });

    canvas.addEventListener("touchmove", evt => {
      if (!draggingPoint) return;
      const touchPos = getTouchPos(evt.touches[0]);
      draggingPoint.x = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, touchPos.x));
      draggingPoint.y = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, touchPos.y));
      drawCanvas();
      lastTouchPos = touchPos;
      evt.preventDefault();
    }, { passive: false });

    canvas.addEventListener("touchend", () => {
      if (draggingPoint) recordMove(draggingPoint);
      draggingPoint = null;
      hoveredPoint = null;
      drawCanvas();
    }, { passive: false });

    // Mouse handlers
    canvas.addEventListener("mousedown", evt => {
      const mousePos = getMousePos(evt);
      lastMousePos = mousePos;
      draggingPoint = findPoint(mousePos) || null;
      drawCanvas();
    });

    canvas.addEventListener("mousemove", evt => {
      const mousePos = getMousePos(evt);
      const newHoveredPoint = findPoint(mousePos);

      canvas.style.cursor = newHoveredPoint ? "grab" : "default";

      if (newHoveredPoint !== hoveredPoint) {
        hoveredPoint = newHoveredPoint;
        drawCanvas();
      }

      if (draggingPoint) {
        draggingPoint.x = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, mousePos.x));
        draggingPoint.y = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, mousePos.y));
        drawCanvas();
      }

      lastMousePos = mousePos;
    });

    canvas.addEventListener("mouseup", () => {
      if (draggingPoint) recordMove(draggingPoint);
      draggingPoint = null;
      canvas.style.cursor = "default";
    });

    canvas.addEventListener("mouseleave", () => {
      draggingPoint = null;
      hoveredPoint = null;
      canvas.style.cursor = "default";
      drawCanvas();
    });

    // Initial draw
    drawCanvas();

    // Form handling
    const form = document.querySelector("form");
    const nextButton = document.querySelector("button[type=submit], .otree-btn-next");

    if (nextButton) {
      nextButton.addEventListener("click", e => {
        e.preventDefault();
        if (!allPointsInsideBox()) {
          {% if lan_en %}
          alert("Please place all dots inside the positioning square before continuing.");
          {% else %}
          alert("Platzieren Sie bitte alle Punkte innerhalb des Rechtecks.");
          {% endif %}
          return;
        }
        document.getElementById("positions").value = JSON.stringify(points);
        form.submit();
      });
    }
  });
</script>

<script>
  function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw the boundary square with enhanced styling
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, canvas.height, canvas.height);

    // Draw all points
    points.forEach((p) => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);

      // Set fill color based on type
      ctx.fillStyle = p.color;
      ctx.fill();

      // Add border with hover effect
      ctx.strokeStyle = p === hoveredPoint ? "#fff" : "#333";
      ctx.lineWidth = p === hoveredPoint ? 3 : 2;
      ctx.stroke();

      // Draw name with better positioning
      ctx.fillStyle = "#333";
      ctx.font = "12px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(p.name_disp, p.x, p.y - 15);
    });
  }

  function recordMove(dot) {
    const now = Math.floor(Date.now() / 1000);
    if (dot.t_first_moved === -1) dot.t_first_moved = now;
    dot.t_last_moved = now;
  }

  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top,
    };
  }

  function getTouchPos(touch) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: touch.clientX - rect.left,
      y: touch.clientY - rect.top,
    };
  }

  function findPoint(pos) {
    return points.find((p) => Math.hypot(p.x - pos.x, p.y - pos.y) < p.radius);
  }

  // Validation function for boundary checking
  function allPointsInsideBox() {
    return points.every(
      (p) =>
        p.x >= 0 && p.x <= canvas.height && p.y >= 0 && p.y <= canvas.height
    );
  }
</script>

{% endblock %}
