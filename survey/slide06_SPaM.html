{% block styles %}
<link rel="stylesheet" href="{{ static 'main.css' }}" />
{% endblock %} {% block content %}
<script src="{% static 'colors.js' %}"></script>

<div class="container">
  <h2>{{page_title}}</h2>

  <p>{{instru1}}</p>

  <p>{{instruRoom}}</p>

  <div
    class="instructions"
    style="
      margin: 10px 0;
      padding: 10px;
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      border-radius: 4px;
    "
  >
    {{instru_main}}
  </div>

  <div
    class="instructions"
    style="
      margin: 10px 0;
      padding: 10px;
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      border-radius: 4px;
    "
  >
    {{no_wrong_answers}}
  </div>

  <canvas
    id="dragCanvas"
    width="620"
    height="500"
    style="
      border: 0px solid #333;
      background: #fafafa;
      display: block;
      margin: 20px 0;
      cursor: grab;
      touch-action: none;
    "
  ></canvas>

  <input type="hidden" name="positions" id="positions" />
</div>
<div
  class="instructions"
  style="
    margin: 20px 0;
    padding: 15px;
    background: rgb(255, 235, 235);
    border-left: 4px solid rgb(255, 0, 0);
    border-radius: 4px;
  "
>
  <p style="margin: 0; color: rgb(0, 0, 0)">{{all_dots_instr}}</p>
</div>

<div style="display: flex; justify-content: space-between; align-items: center">
  {% if lan_en %} {{ next_button }}
  <div style="margin-left: auto">Page {{nslide}}/{{maxslides}}</div>
  {% else %}
  <button type="submit" class="otree-btn-next btn btn-primary big-button">Weiter</button>
  <div style="margin-left: auto">Seite {{nslide}}/{{maxslides}}</div>
  {% endif %}
</div>

<script>
  // Run only after everything (DOM + CSS + fonts) is ready
  window.addEventListener("load", function () {
    const canvas = document.getElementById("dragCanvas");
    const ctx = canvas.getContext("2d");

    const points = [
      {% for dot in dots %}
      {
        name_disp: "{{ dot.name_disp }}",
        varname: "{{ dot.varname }}",
        x: {{ dot.x }},
        y: {{ dot.y }},
        dottype: "{{ dot.dottype }}",
        descr: "{{ dot.descr }}",
        radius: 12,
        t_last_moved: {{ dot.t_last_moved }},
        t_first_moved: {{ dot.t_first_moved }}
      },
      {% endfor %}
    ];

    let draggingPoint = null,
        hoveredPoint = null,
        lastMousePos = { x: 0, y: 0 },
        lastTouchPos = { x: 0, y: 0 };

    console.log("Loaded points:", points);

    function recordMove(dot) {
      const now = Math.floor(Date.now() / 1000);
      if (dot.t_first_moved === -1) dot.t_first_moved = now;
      dot.t_last_moved = now;
    }

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Boundary square
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 1;
      ctx.strokeRect(0, 0, canvas.height, canvas.height);

      // Points
      points.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = COLORS[p.varname] || COLORS[p.dottype] || "white";
        ctx.fill();

        ctx.strokeStyle = p === hoveredPoint ? "#fff" : "#333";
        ctx.lineWidth = p === hoveredPoint ? 3 : 2;
        ctx.stroke();

        ctx.fillStyle = "#333";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText(p.name_disp, p.x, p.y - 15);
      });
    }

    const getMousePos = evt => {
      const rect = canvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    };

    const getTouchPos = touch => {
      const rect = canvas.getBoundingClientRect();
      return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    };

    const findPoint = pos =>
      points.find(p => Math.hypot(p.x - pos.x, p.y - pos.y) < p.radius);

    // Prevent native drag
    ["dragstart", "drag", "dragend"].forEach(ev =>
      canvas.addEventListener(ev, e => e.preventDefault())
    );

    // Touch handlers
    canvas.addEventListener("touchstart", evt => {
      const touchPos = getTouchPos(evt.touches[0]);
      lastTouchPos = touchPos;
      draggingPoint = findPoint(touchPos) || null;
      drawCanvas();
      evt.preventDefault();
    }, { passive: false });

    canvas.addEventListener("touchmove", evt => {
      if (!draggingPoint) return;
      const touchPos = getTouchPos(evt.touches[0]);
      draggingPoint.x = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, touchPos.x));
      draggingPoint.y = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, touchPos.y));
      drawCanvas();
      lastTouchPos = touchPos;
      evt.preventDefault();
    }, { passive: false });

    canvas.addEventListener("touchend", () => {
      if (draggingPoint) recordMove(draggingPoint);
      draggingPoint = null;
      hoveredPoint = null;
      drawCanvas();
    }, { passive: false });

    // Mouse handlers
    canvas.addEventListener("mousedown", evt => {
      const mousePos = getMousePos(evt);
      lastMousePos = mousePos;
      draggingPoint = findPoint(mousePos) || null;
      drawCanvas();
    });

    canvas.addEventListener("mousemove", evt => {
      const mousePos = getMousePos(evt);
      const newHoveredPoint = findPoint(mousePos);

      canvas.style.cursor = newHoveredPoint ? "grab" : "default";

      if (newHoveredPoint !== hoveredPoint) {
        hoveredPoint = newHoveredPoint;
        drawCanvas();
      }

      if (draggingPoint) {
        draggingPoint.x = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, mousePos.x));
        draggingPoint.y = Math.max(draggingPoint.radius, Math.min(canvas.height - draggingPoint.radius, mousePos.y));
        drawCanvas();
      }

      lastMousePos = mousePos;
    });

    canvas.addEventListener("mouseup", () => {
      if (draggingPoint) recordMove(draggingPoint);
      draggingPoint = null;
      canvas.style.cursor = "default";
    });

    canvas.addEventListener("mouseleave", () => {
      draggingPoint = null;
      hoveredPoint = null;
      canvas.style.cursor = "default";
      drawCanvas();
    });

    // Initial draw
    drawCanvas();

    // Validation
    function allPointsInsideBox() {
      return points.every(p =>
        p.x >= 0 && p.x <= canvas.height &&
        p.y >= 0 && p.y <= canvas.height
      );
    }

    // Form handling
    const form = document.querySelector("form");
    const nextButton = document.querySelector("button[type=submit], .otree-btn-next");

    if (nextButton) {
      nextButton.addEventListener("click", e => {
        e.preventDefault();
        if (!allPointsInsideBox()) {
          {% if lan_en %}
          alert("Please place all dots inside the positioning square before continuing.");
          {% else %}
          alert("Platzieren Sie bitte alle Punkte innerhalb des Rechtecks.");
          {% endif %}
          return;
        }
        document.getElementById("positions").value = JSON.stringify(points);
        form.submit();
      });
    }
  });
</script>

{% endblock %}
